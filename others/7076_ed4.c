/*******************************************************************************
【文件名称】    7076_ED4.C
【实现功能】    SWP7076EX安全栅
【作者信息】    作者:章云区,福州昌晖自动化系统有限公司
【版本信息】    当前版本V2.00
【修改日志】    2007年,创建本文件,版本号V1.00,创建人郑新
				2010年6月25日 ，  版本号V2.00,章云区修改
                        2011年\2012年 ，  版本号V1.0, 张シ逍薷
--------------------------------------------------------------------------------

*******************************************************************************/
//----------------------------------------------------------------       头文件
#include <stdio.h>
#include <stdlib.h>
#include <MSP430x13x.h>

#define	U8		unsigned char

//---------------------------------------------------------------全局配置预定义
#define  	ADDR_RTD   	(1<<3)          	//P1.3
#define  	DIR_RTD    	P1DIR
#define  	OUT_RTD    	P1OUT

//阻型断偶判断使用端口输出
#define  	ADDR_TC   	(1<<4)         	//P1.4
#define  	DIR_TC    	P1DIR
#define  	OUT_TC    	P1OUT

//ADS1110端口
#define  	ADSSDA   	(1<<4)       	//P6.4
#define  	ADSSCL   	(1<<3)        	//P6.3

//DS18B20端口
#define  	ADDR_DS  	(1<<0)		//P5.0
#define  	PDIR_DS   	P5DIR
#define  	POUT_DS   	P5OUT
#define  	PIN_DS    	P5IN
//-----------------------------------------------------------------------------

#define  	RS485    	0x08
//-----------------------------------------------------------------------------


/* 以AD线性转换采样输入信号的的初始脉冲为Y轴, 以阻型、偶型输入信号为X轴，构造坐标,取两点进行校对 */
//分度号全可切处理      y0,y1上下限两点脉冲校对表   zyf++.2011.3.8
const float  y0y1_mc_table[11][2]=
{
            //  y0,y1值修改  zyf++.2011.9.24
                 0,     17338.02,
            259.55,      12889.37,
            615.11,      4834.16,
            651.85,      3676.73,
            4775.05,     15848.91,
            624.42,      3951.17,            
            0,          6088.57,
            
            4638.44,     17520.86,
            4153.10,     14069.54,          
            7571.03,    16703.06, 
  
            /* L型: WRE5-26 */            
            //   0,          6465.13,   
            0,          6457.19,             
};


#define     fdh_LEN     11 
const int quxian[fdh_LEN][37]=
{ 
    /*  改后 */  
      0,  2843,  3954,   4817,  5554,  6211,  6811,  7369,  7891,  8386,  8859,
    9312,  9749, 10171,  10579, 10978, 11367, 11747, 12119, 12484, 12843, 13196,
    13544, 13888, 14228, 14564, 14898, 15230, 15560, 15889, 16217, 16545, 16873,
    17202, 17533, 17865, 18200, //B--0 

    /*  改后 */
    -500,   486,  1227,  1882,   2492,  3077,  3642,  4193,  4733,  5264,  5787,
    6302,  6808,  7306,  7798,   8280,  8756,  9225,  9688, 10144, 10596, 11042,
    11484, 11923, 12359, 12793, 13227, 13661, 14094, 14528, 14963, 15402, 15842,
    16286, 16735, 17194, 17680,//S--1
   
    -500,    -79,   316,   698,  1079,  1465,  1859,  2253,  2641,  3023,  3402,//10
    3778,   4151,  4523,  4894,  5264,  5634,  6004,  6375,  6749,  7124,  7503,//21
    7884,   8270,  8659,  9052,  9449,  9851, 10256, 10666, 11081, 11502, 11929,//32
    12364, 12807, 13260, 13720,//K--2

    -500,   -101,   269,   620,   954,  1276,  1587,  1890,  2186,  2477,  2764,
    3047,   3327,  3605,  3882,  4156,  4430,  4702,  4974,  5246,  5518,  5789,
    6062,   6335,  6609,  6883,  7159,  7436,  7714,  7994,  8275,  8557,  8842,
    9128,   9417,  9708, 10000,//E--3

    /*  改后 */   
  -20000, -16662,-13925,-11534, -9376, -7388, -5530, -3775, -2103,  -503,  1039,
    2538,   3992,  5404,  6779,  8119,  9429, 10712, 11972, 13207, 14425, 15622,
   16803,  17966, 19116, 20250, 21371, 22480, 23577, 24662, 25738, 26802, 27858,
   28905,  29945, 30976, 32000,//T--4       两位小数点  
 
    -500,    -86,   306,   685,  1055,  1420,  1782,  2142,  2502,  2862,  3224,
    3586,   3948,  4311,  4672,  5030,  5385,  5735,  6078,  6415,  6745,  7068,
    7385,   7698,  8008,  8318,  8631,  8948,  9270,  9599,  9933, 10272, 10614,
    10959, 11305, 11652, 12000,//J--5

    /*  改后 */   
        0,   960,  1732,  2416,  3049,  3648,  4224,  4786,  5335,  5879,  6416,
     6952,  7486,  8020,  8555,  9092,  9634, 10180, 10732, 11290, 11855, 12428,
    13009, 13600, 14200, 14810, 15432, 16066, 16714, 17378, 18060, 18764, 19496,
    20264, 21083, 21976, 23000,//6: L 3-25



    -5000, -4452, -3899, -3350, -2797, -2245, -1694, -1140,  -586,   -33,   522,
     1076,  1631,  2189,  2744,  3298,  3856,  4413,  4971,  5529,  6087,  6643,
     7199,  7757,  8316,  8874,  9432,  9988, 10546, 11105, 11660, 12219, 12774,
    13329, 13885, 14443, 15000,//7:CU50    两位小数点         

    -1999, -1767, -1529, -1288, -1042,  -793,  -541,  -286,   -29,   231,   494,
      759,  1027,  1298,  1571,  1848,  2127,  2409,  2695,  2984,  3276,  3571,
     3870,  4173,  4479,  4790,  5104,  5422,  5745,  6072,  6404,  6740,  7082,
     7428,  7780,  8137,  8500,//8:PT100

   -19990,-18719,-17433,-16134,-14822,-13498,-12162,-10814, -9456, -8088, -6711,
    -5325, -3930, -2527, -1117,   302,  1728,  3161,  4602,  6052,  7509,  8974,
    10447, 11929, 13419, 14917, 16424, 17940, 19465, 20999, 22542, 24094, 25656,
    27227, 28809, 30399, 32000,//9:PT100.1   两位小数点


   /*     
    0,    724,   1383,   2000,  2587,  3155,  3707,  4249,  4784,  5313,  5841, 
    6367, 6895,  7424, 7958,  8495,  9039,  9590,  10149,  10717,  11295, 11884,
    12485, 13099, 13727, 14369, 15028, 15705, 16401, 17117, 17857, 18624, 19422,
    20258, 21143, 22096, 23150,//新增加的WRe5-26  一位小数点  0~2315量程
 */ 

    0,    724,   1384,   2002,  2590,  3158,  3711,  4254,  4789,  5319,  5847, 
    6374, 6902,  7433, 7967,  8505,  9050,  9602,  10162,  10730,  11309, 11899,
    12501, 13116, 13745, 14389, 15049, 15728, 16425, 17143, 17885, 18653, 19453,
    20292, 21181, 22138, 23200,//10:新增加的WRe5-26   一位小数点   0~2320量程  zyf.2011.9.14++     
};


//设置参数的地址
#define  	FSEGA    	0x1080
#define  	FSEGB    	0x1000
#define  	FSEG     	0x0080

#define  	ADR_DE    	0x1020
#define  	ADR_BT    	0x1021

#define  	ADR_FDH  	0x1028			// 分度号
#define  	ADR_DOT  	0x1029

//zyf++.2011.3.9
 /******************************/
#define     R11_ADR_AD_N  0x102A                 // CU50_AD采样信号零点修正值
#define     R12_ADR_AD_K  0x102C                 // CU50_AD采样信号比例修正值

#define     R21_ADR_AD_N  0x102E                 // PT100_AD采样信号零点修正值 
#define     R22_ADR_AD_K  0x1030                 // PT100_AD采样信号比例修正值

#define     R31_ADR_AD_N  0x1032                 // PT100.1_AD采样信号零点修正值
#define     R32_ADR_AD_K  0x1034                 // PT100.1_AD采样信号比例修正值

#define  	TC_ADR_AD_N    0x1036      		// AD采样信号零点修正值 (偶型)
#define  	TC_ADR_AD_K    0x1038               // AD采样信号比例修正值 (偶型)
 /******************************/

#define  	R_OFF_FLAG   0x1041                 // 阻型断耦处理的判断标志     zyf++.2011.5.26
 /******************************/ 

#define  	ADR_RB_N1   0x1044 	      	//冷补（内部）
#define  	ADR_RB_K1   0x1046
#define  	ADR_RB_N0   0x1048 	      	//冷补（外部）
#define  	ADR_RB_K0   0x104A


 /*********************************************/
//作温漂简单线性补偿用地址分配 ZYF++.2012.6.29
#define     T_value_ref       0x105C 
#define  	K_add1            0x104C
#define  	K_add2            0x104E            
 /*********************************************/


#define	DA_PY		0x10				// DA1 与 DA2 的参数地址偏移 (10 -> 0x10)
#define  	ADR_DW1_NN  0x1054			// 第1路 变送输出电位器 修正零点 保存值
#define  	ADR_DW1_KK  0x1056			// 第1路 变送输出电位器 修正比例 保存值
#define  	ADR_DA1_N  	0x1058			// 第一变送校对零点
#define  	ADR_DA1_K  	0x105A			// 第一变送校对比例

#define  	ADR_DW2_NN  (ADR_DW1_NN+DA_PY)	// 第2路 变送输出电位器 修正零点 保存值
#define  	ADR_DW2_KK  (ADR_DW1_KK+DA_PY)	// 第2路 变送输出电位器 修正比例 保存值
#define  	ADR_DA2_N  	(ADR_DA1_N+DA_PY)		// 第二变送校对零点
#define  	ADR_DA2_K  	(ADR_DA1_K+DA_PY)		// 第二变送校对比例

#define  	ADR_DA1_L   0x1050                  // 第1路输出 采样量程: 下限温度值(zyf++)
#define  	ADR_DA1_H   0x1052                  // 第1路输出 采样量程: 上限温度值(zyf++)
#define  	ADR_DA2_L   (ADR_DA1_L+DA_PY)       // 第2路输出 采样量程: 下限温度值(zyf++)
#define  	ADR_DA2_H   (ADR_DA1_H+DA_PY)       // 第1路输出 采样量程: 上限温度值(zyf++)


#define  	ADRCLK1  	0x1076
#define  	ADRCLK2  	0x1078

#define  	ADRFUN3  	0x107E


union intchar  
{
	int            sint;
    	unsigned int   usint;
    	U8  ch[2];
}inch;

struct caidang
{
      unsigned int  address;        //数据地址
      unsigned char leng;           //数据长度
      int           hign;           //数据下限
      int           low;            //数据上限  
      int           set;       		 //设定值
};



#define  	CD_LEN      	30    	
const struct caidang caidan[CD_LEN]=
{
      //地址            长度        上限        下限        设定值
      //一级参数
      //二级参数(通讯）  
      ADR_BT,           1,          7,          0,          2,          //波特率
      ADR_DE,           1,          255,        0,          1,          //设备号
      ADR_FDH,          1,          10,         0,          2,          //分度号( 缺省2 = K)
 
      //三级参数(仪表功能） 
      ADRFUN3,          2,          9999,       0,          3,          //仪表内部参数3

/*****************************************************************************************/
      // ZYF++.2011.3.9
      /***********************************/
      ADR_RB_N0,        2,          0,          0,          0,           // 外冷补修正
      ADR_RB_K0,        2,          0,          0,          16384,      
      ADR_RB_N1,        2,          0,          0,          0,           // 内冷补修正
      ADR_RB_K1,        2,          0,          0,          16384,      
                                                                        //变送输出修正
      ADR_DA1_N,        2,          0,          0,          0,           //第1路变送输出零点修正  
      ADR_DA1_K,        2,          0,          0,          16384,       //第1路变送输出比例修正
      ADR_DA2_N,        2,          0,          0,          0,           
      ADR_DA2_K,        2,          0,          0,          16384,      
                                                                       // 变送输出:(0-20ma)，0-5v，特殊电流，特殊电压
      ADR_DA1_L,        2,          0,          0,          0,          // 第1路 输出下限     
      ADR_DA1_H,        2,          0,          0,          10000,      // 第1路 输出上限
      ADR_DA2_L,        2,          0,          0,          0,          // 第2路 输出下限      
      ADR_DA2_H,        2,          0,          0,          10000,      // 第2路 输出上限 

      // ZYF++.2011.3.9
      /***********************************/
      TC_ADR_AD_N,        2,          0,          0,          0,           // AD采样信号修正值(偶型)
      TC_ADR_AD_K,        2,          0,          0,          16384,  
      
      R11_ADR_AD_N,        2,          0,          0,          0,           // AD采样信号修正值(阻型: CU50)
      R12_ADR_AD_K,        2,          0,          0,          16384,          
      R21_ADR_AD_N,        2,          0,          0,          0,           // AD采样信号修正值(阻型: PT100)
      R22_ADR_AD_K,        2,          0,          0,          16384,   
      R31_ADR_AD_N,        2,          0,          0,          0,           // AD采样信号修正值(阻型: PT100.1)
      R32_ADR_AD_K,        2,          0,          0,          16384,  
     /***********************************/

     //zyf++.2011.5.26
    /******************************/ 
       R_OFF_FLAG,          1,          3,         0,          0,             // 阻型断耦处理的判断标志        
   /******************************/  

    //zyf++.2012.6.29
       T_value_ref,     2,          0,          0,          25,            //作温漂简单线性补偿用的温度变化前的基准值(-20~60)
       K_add1,          2,          0,          0,          0,            //第1路温漂线性补偿系数值
       K_add2,          2,          0,          0,          0,            //第2路温漂线性补偿系数值
   /******************************/ 

/*****************************************************************************************/
 
    //四级参数(变送校对)
    ADRCLK1, 2,         9999,       0,        0x0000,   //模拟量输出下限
    ADRCLK2, 2,         9999,       0,        0x0000,   //模拟量输出上限
};
/*****************************************************************************************/


//通用子程序
void          ZHUPRO(void),Init(void),delay(int del);

//读写430的内部FLASH
int           FLASH_RW(unsigned int,U8);
void          FLASH_WW(unsigned int,int,U8);
void          FLASH_CLR(unsigned int);
void          FLASH_MCLR(unsigned int);
void          FLASH_COPY(void);
void          FLASH_CHU(void);						// 初始化FLASH
void          READ_CHU(void);

//线性化曲线与反线性化曲线
int           XIANXINHUA( U8,int);
int           AXIANXINHUA(U8,int);

//读写ADS11**系列
enum ENM_ADS1110_ADDR
{
    ED0=0x90,
    ED1=0x92,
    ED2=0x94,
    ED3=0x96,
    ED4=0x98,
    ED5=0x9a,
    ED6=0x9c,
    ED7=0x9e
};

U8  ADS_ADDR=ED4;

void	get_ads_adr(void);			// 取得ADS1110的地址
void  adsread(void);				// 按地址读一字节
void  adswrite(U8 data);			// 按地址写一字节
void  adsiicstart(void);			// iic 起始信号
void  adsiicstop(void);				// iic 停止信号
U8 	adswbyte(U8 byte);			// iic 写1字节
U8 	adsrbyte(void);				// iic 读1字节

//通讯
void  WTXDB(U8 ch);				// 单字节发送
void	DWTXDB(U8 ch);				// 单字节转为ASC码双字节发送
void  ERROR(void);				// 出错应答
void	RIGHT(void);				// 正确应答
U8 	ASCTOBIN(U8);				// ASC码转二进制
U8 	BINTOASC(U8);
U8 	RRXDB(void);				// 单字节读

U8 	crc,rovti,rov,de,uch,uchh,uchl,eeprom;
unsigned int  uadr;

//DS18B20
int 	read_temp(void);				// 读室温值
char 	Reset_ds(void);				
void 	Write_ds(U8 data);			// 写
int 	Read_ds(void);
//----------------------------------------------------------------------------------------


//变量区
int   dognum;               			// 看门狗
U8 	fdh,fdh_last=0;     			// 分度号
int   i,j,zj1,zj2,zj3;      			// 中间单元
U8 	leng=250;             			// 变送模拟输出
U8 	samdot;               			// 采样情况
int   adsam[16];            			// 采样数组(冷补0-1,通道2-4，通道5-7，通道8-10,
                                    	// 11=室温,12=通道1,13=通道2,14=通道3,15=sv
U8  	samnum=0;
U8 	adsdata[3];

U8 	R_off_flag=0;                       // 阻型的断偶处理判断标志   zyf++
/**********************************/

//滤波变量定义  zyf++.2011.2.22
#define  hd_num  5 
unsigned int  hd_cnt=0; 
#define  filter_num  20 
unsigned int  filter_cnt=0; 
unsigned int  rb_filter_table[filter_num];

#define  rb_filter_KG   0
#define  rb_filter1_KG  0   
/**********************************/ 

//内冷补TC1047宏定义: 用于线性计算  zyf++.2011.2.23
#define  tc1047_t100  4970 
#define  tc1047_t0  1600 
/**********************************/ 



/************************************************/
/*
      unsigned char    
      unsigned long     
      long  
      int 
      float 
*/

int test_TT1;
unsigned int test_TT2;

//作温漂简单线性补偿用变量定义 ZYF++.2012.6.29
float K_add=0; 

//作温漂简单线性补偿用参数宏定义 ZYF++.2012.6.29
#define     T_test      60
#define     T_ref       30  
/*    
//第1台试验结果
#define     I_value_test1     11954
#define     I_value_ref1      12010
#define     I_value_test2     11912
#define     I_value_ref2      12000   
*/
   
//第2台试验结果
#define     I_value_test1     11970
#define     I_value_ref1      12000
#define     I_value_test2     11988
#define     I_value_ref2      12000 
/************************************************/ 



/************************************************/ 
#define ABS(X) ((X)>=0?(X):(0-(X)))
/************************************************/
void delay(int del)
{
    for (;del>10;del--) _NOP();
}

/***********************************************************************/
/*  看门狗中断                                                     */ 
/***********************************************************************/
// LED+LCD显示 8/6=1.3333333ms
#pragma vector = WDT_VECTOR
__interrupt void WDT(void)
{
    dognum++;
    rovti++;
}
/***********************************************************************/
/* Timer_B 初始化                                                      */
/***********************************************************************/
#define  IOUT  10000
void PWM_init(void)
{ 
	P1SEL|= BIT6;P1DIR|= BIT6;
  	P1SEL|= BIT7;P1DIR|= BIT7;
  	TACCR0=16000;
  	TACCR1=IOUT;
  	TACCR2=IOUT;
  	TACCTL0=0;
  	TACCTL1=0x02C0;
  	TACCTL2=0x02C0;
  	TACTL=0x0216;
}

/***********************************************************************/
/* Timer_B 更新                                                        */
/***********************************************************************/
void PWM_update( void )
{ 
  	TACCR1=IOUT;
  	TACCR2=IOUT;
}
 
/***********************************************************************/
/* Timer_B 中断                                                        */
/***********************************************************************/
#pragma vector=TIMERA1_VECTOR
__interrupt void Timer_A(void)
{ 
	switch( TAIV ) 
	{ 
		case  2: break;
            case  4: break;
            case  6: break;
            case  8: break;
            case 10: break;
            case 12: break;
            case 14: PWM_update();break;
     	}
}

/****************** 新增WRe5-26型后判断条件新修改.zyf++.2012.6.13 ******************/
  /*** 
  分度号处理内容(只上电处理一次的): 上拉电阻选择 + 计算用放大倍数选择
  阻型上拉电阻选择 -> 用于构建桥式采样电路
  偶型上拉电阻选择 -> 用于断偶时分压采样处理
  ***/ 
void	fdh_do(void)                  // 分度号的部分处理内容
{
    	//上拉电阻选择
    	DIR_RTD |=ADDR_RTD;
    	if((fdh<7)||(fdh==10))                                      // 热电偶
    	{
        	OUT_RTD &=~ADDR_RTD;
        	OUT_TC  |= ADDR_TC;
    	}
    	else
    	{
        	OUT_RTD |= ADDR_RTD;						// 热电阻上拉
        	OUT_TC  &=~ADDR_TC;
    	}
      
     // 放大倍数选择 
    	if((fdh<=7)||(fdh==10))       adswrite(0x8f);         // 除PT100均提高放大倍数  
    	else              adswrite(0x8e);        
}
/**********************************************************************************/



/**********************************************************************************/
void main(void)
{
    	P6DIR=0XFF;P6SEL=0XE7;
    	P5DIR=0XFF;P5SEL=0X00;
    	P4DIR=0XFF;P4SEL=0X00;
    	P3DIR=0X7F;P3SEL=0X30;P3OUT=0x01;               //通讯
    	P2DIR=0XE7;P2SEL=0X18;
    	P1DIR=0XFF;P1SEL=0XC0;

    	for (j=0;j<50;j++)
    	{
        	for (i=0;i<15;i++) adsam[i]=0;
    	}    

    	Init();         
    	//PWM_init();                                                           
    	FLASH_CHU();                                    // 初始化FLASH                 	
    	de 	= *(U8 *)ADR_DE;
    	fdh = *(U8 *)ADR_FDH;                           // 取分度号
    	ADC12CTL0 &= (~ENC);
    	ADC12CTL0 = MSC+REF2_5V+REFON+ADC12ON;
    	ADC12CTL0 |= ENC;

	fdh_do();									// 分度号处理
    	_EINT();                                                    // 开中断
    	samnum=200;
    	eeprom=80;
     
      
      /***********************************/ 
      // 第三种滤波    zyf++.2011.2.22
      adsam[1] = ADC12MEM1;  
      adsam[1] += ADC12MEM2; 
      /***********************************/      

    	for (;;)
    	{
        	P3OUT=P3OUT&(~RS485);						// ???

        	if (dognum>100)							// 看门狗中断进入		133.33ms 执行1次
        	{
            	dognum=0;                  
            	ZHUPRO();               /****** 不断循环地进行: 采样 + 输出处理 ******/                  
            	if (eeprom!=0) eeprom++;				// EEPROM 写延迟判断
        	}

            if (leng==0x40)                                       //写入调校时的电位器值
            {
      	      eeprom=4;
                  FLASH_WW(ADR_DW1_KK+0x80,adsam[5],2);  
                  FLASH_WW(ADR_DW1_NN+0x80,adsam[6],2);
                  FLASH_WW(ADR_DW2_KK+0x80,adsam[7],2);
                  FLASH_WW(ADR_DW2_NN+0x80,adsam[8],2);    
                  leng = 0; 
     	      }

       	if (eeprom >3)							// 延迟写时间到，进行FLASH参数拷贝
        	{
            	eeprom=0;

            	FLASH_COPY();						// 拷贝FLASH参数到保存区
            	Init();							// ???
            	de = *(U8 *)ADR_DE;					// 重新获取站地址
        	}

        	fdh=*(U8 *)ADR_FDH;						// 读取有效 分度号
        	if (fdh!=fdh_last)
        	{
            	fdh_last=fdh;
			fdh_do();							// 分度号处理
        	}
    	}
}


//处理程序
void ZHUPRO(void)
{
      int 	old_val;  
    	U8          num_NK;           //零点比例电位器修正用变量
    	float      k_df;              //零点比例电位器修正用变量
            
      U8          num;       
      unsigned long        k;      
      long        sll,slh;
      int         sam12;
    	int         sam; 

      int  nnn;
      unsigned int 	kkk;
      
      unsigned int 	i_duanou=0;

    	// ------------------- 室温采样校对 -----------------------
    	ADC12IFG = 0;
    	ADC12CTL0 &= ~0x0001;
    	ADC12CTL0 |= 0x0001;
    
    	slh = read_temp();                        // 读取 18B20 中的室温值
    	while ((ADC12IFG&(1<<5))==0);             //判断采样完成    

      //读取ADRFUN3标志
      kkk=*(unsigned int *)ADRFUN3;
      //增当ADRFUN3第３位置1时，不进行冷端补偿
      if((kkk&(4))!=0)
      {
            adsam[11]=0;
      }
      
      else if(slh == -16384)                    //没接18B20,使用内部补偿得到的室温
      {
      
      /***********************************/ 
      // 取冷补用室温采样瞬时值 zyf++.2012.10.24
      nnn = ADC12MEM1;  
      nnn += ADC12MEM2;     

      //室温采样值进行加权滤波   
      adsam[1] = (int)((float)(0.9*adsam[1])+(float)(0.1*nnn));       
      adsam[11]=(int)((float)(adsam[1] - tc1047_t0)/((float)(tc1047_t100-tc1047_t0)/100));   //线性换算成气温 zyf++.2012.7.4
      
      /*
      //不进行滤波直接取瞬时室温采样值
      adsam[1] = nnn;         
      */      
      
      /***********************************/   
      }
      
      else                    //有接18B20,使用18B20外部补偿得到的室温
      {
        ;
      }
      /******************************************************************/
      
      
    	// ------------------------- 通道计算 ------------------------------
      /******************************************************************/ 
    	adsread(); 
      /******************************************************************/  
       
      /****************** 新增WRe5-26型后判断条件新修改.zyf++.2011.7.13 ******************/
      if ((fdh>6)&&(fdh<10))                                            
	{
      	sam=(adsdata[0]<<8) + adsdata[1];
	} 
      else              
      {
		/******** 针对偶型某些表的上位机校对公式计算的NN值可能大于32768的专门处理 .zyf++.2011.7.25 ********/         
        	sam=(adsdata[0]<<8) + adsdata[1]+2500;   //把采样值整体往上垫2500，使其在K值不变情况下减小X0值,以达到减小NN值目的      
	}
      
     /******************/ 
      /*
      阻型正常信号采样脉冲范围：-9000~20000 
      偶型正常信号采样脉冲范围：-11000~31000 
      统一取范围：-20000~31000 为正常范围
      */
      //阻型+偶型断偶判断
	if ((sam<-20000)||(sam>31000))	
	{
		i_duanou=1;
	}     
      /******************/ 

      //不滤波直接更新AD1110的采样值 .zyf++.2012.7.3      
      adsam[4] =sam; 
      
      /*	
      //对AD1110的采样值进行加权滤波 .zyf++.2011.7.29      
      adsam[4] = (int)((float)(0.2*adsam[4])+(float)(0.8*sam));           
      */      
      /******************************************************************/ 
      
       // 分度号全可切处理  zyf++.2011.3.8    
      /*********************** 偶型 ****************************************/    
      /******* 全可切默认校对类型修改(B改为S) zyf++.2011.9.22   新增WRe5-26型后判断条件新修改. **********/        
      if(fdh==1)                          // 偶型(S型) 
       {
            nnn=*(int *)(TC_ADR_AD_N);
            kkk=*(int *)(TC_ADR_AD_K);                
       }
      else if((fdh<7)&&(fdh!=1))          // 偶型(S型除外)
       {
            nnn=*(int *)(TC_ADR_AD_N);
            kkk=*(int *)(TC_ADR_AD_K);          
            k = kkk; 
            kkk = (int)((unsigned long)kkk*(y0y1_mc_table[fdh][1] - y0y1_mc_table[fdh][0])/(12889.37-259.55)); 
            nnn = (int)(y0y1_mc_table[fdh][0] - (long)kkk*(259.55-nnn)/k);          
       }    
      
     /*************************** 阻型 **************************************/       
     else if (fdh==7)                           // CU50
       {
     	      nnn=*(int *)(R11_ADR_AD_N);
     	      kkk=*(int *)(R12_ADR_AD_K);
       } 
      else if (fdh==8)                          // PT100
       {
     	      nnn=*(int *)(R21_ADR_AD_N);
     	      kkk=*(int *)(R22_ADR_AD_K);
       } 
      else if (fdh==9)                          // PT100.1
       {
     	      nnn=*(int *)(R31_ADR_AD_N);
     	      kkk=*(int *)(R32_ADR_AD_K);
       }  
     
      else        fdh=0;                  //防止上位机出错分度号
      
      /*************************************************************************/
      
      //对AD采样脉冲值进行零点比例上位机校对修正   zyf++.2011.3.8
       sam=((long)adsam[4]*kkk)/16384+nnn;
       
     /****************** 新增WRe5-26型后判断条件新修改.zyf++.2011.7.13 ******************/  
    	if((fdh<7)||(fdh==10))
    	{
    	   sam += AXIANXINHUA(fdh,adsam[11]);           //电偶，加入冷补温度对应的反线性化查表脉冲
    	}
    	
      sam=XIANXINHUA(fdh, sam);                       // 采样脉冲查表,获得温度值
      
      /*************************************************************************/        
      //预暂存新旧温度值用于后续判断 zyf++.2011.3.3      
      old_val = adsam[12];      
      sam12=sam;   
      /*****************************/
      //两路采样量程都读取第1路量程范围做一样处理      
      sll =(*(int *)(ADR_DA1_L));         //从上位机读取量程范围: 下限温度值
      slh =(*(int *)(ADR_DA1_H));         //从上位机读取量程范围: 上限温度值     
      /*      
      sll = (*(int *)(ADR_DA1_L + DA_PY*num));        //从上位机取变量程范围下限温度值(两路)                   	
      slh = (*(int *)(ADR_DA1_H + DA_PY*num));        //从上位机取量程范围上限温度值(两路)       
      */     
      /*****************************/ 
      //阻型+偶型断偶处理      
	if(i_duanou)                        
		{	
          		switch(*(U8 *)R_OFF_FLAG)		//从上位机取断偶标志  
           		{
            		case 1: 				//设置为下限
                  		sam12=sll;           
                  		break;
            		case 2:                       //设置为上限
                  		sam12=slh;           
                  		break;
            		default :                     //设置为不更新(保持上一次采样值)
            			sam12 = old_val;
            			break;
          		}          
            }
		
      /********************* zyf++.2011.3.3 *******************************/          
      //超量程限幅处理            	
	if((long)sam12 > slh) sam12=slh;
	else if((long)sam12 < sll) sam12=sll;
	adsam[12] = sam12;    
/**********************************************************************************************************/ 
      /* 以上是对外AD1110采样脉冲+TC1047传感器+内置AD采样脉冲的初始处理 + 上位机校对 */
/**********************************************************************************************************/ 


      
/**********************************************************************************************************/        
      /* 以下做变送输出对应的PWM转换脉冲处理 + 上位位机校对 + 电位器校对 */      
/*********************************************************************************************************/   
      
	/****************** 模拟量输出 ******************/          
    	for (num=0;num<2;num++)     //2路
    	{
        /**********************************************************************************/  
            //变送校对时对上位机的光标切换的处理修改 zyf++.2011.4.26         
        	if (leng==0x4E)                           		      //第1路 下限(输出)
        	{
            	TACCR2=3000;      TACCR1=10000;
            	break;
        	}
        	else if (leng==0x4F)        					      //第1路 上限(输出)
        	{
            	TACCR2=16000;     TACCR1=10000;
            	break;
        	}  
           else if (leng==0x50)        					      //第2路 下限(输出)
        	{
            	TACCR1=3000;       TACCR2=10000;
            	break;
        	}  
           else if (leng==0x51)        					      //第2路 上限(输出)
        	{
            	TACCR1=16000;      TACCR2=10000;
            	break;
        	}         

        /**********************************************************************************/  

      //将上述处理后的采样脉冲值线性转换为输出电流所对应的PWM脉冲        
      sam = 4000+ (int)(((long)(adsam[12])-sll)*16000/(slh-sll));      
         /* 
            // 计算溢出计算特殊处理 zyf++.2012.6.13
            分度号4和9项要做特殊处理: 因为是两位小数点值,计算时会溢出:   
            因为有符号整型范围为-32768~+32768，而分度号4和9项:32000-(-19990)=51990 溢出了
          */
      
      //从上位机读取变送输出校对: 零点N和比例K(两路) 
      nnn = (*(int *)(ADR_DA1_N + DA_PY*num));                          	
      kkk = (*(int *)(ADR_DA1_K + DA_PY*num));
      
      //电位器修正 ZYF++.2011.4.13          
      adsam[5] = (int)ADC12MEM0;		//k0         
   	adsam[6] = (int)ADC12MEM3;		//n0
   	adsam[7] = (int)ADC12MEM4;		//k1
   	adsam[8] = (int)ADC12MEM5;		//n1
      
   	for(num_NK=0; num_NK<2; num_NK++)	
      {
        if (num_NK==0)
            {
                  if (num==0)                   //第1路零点修正
                        nnn += ((adsam[6]-2048)/16); 
                  else                          //第2路零点修正 
                        nnn += ((adsam[8]-2048)/16); 
            }
        
        else
            {
            if (num==0)                   //第1路比例修正
                  k_df=adsam[5]-2048;          
        	else                          //第2路比例修正 
                  k_df=adsam[7]-2048; 
            }
      }            
        /**************************************************/ 

      //上位机校对修正 + 电位器修正处理 ZYF++.2011.4.13
      sam=(int)((long)sam*kkk/16384+sam*k_df/2048*0.016+nnn);         
      
      /*       
      新系数1为:       16,   0.016  -> 即比旧系数放大了: 2.5倍,3.2倍
      
       比例微调变化率(4096-2048)/2048*2*0.016(调整率)=0.032，即: 最大变化量为20.000*0.032=0.640mA,最小变化量为4.000*0.032=0.128mA
           即: 最大变化时，输出电流每变化0.1%(0.016mA),对应电位器值要变化: 4096/(0.640/0.016)=102 (电位器分成40档来旋)
               最小变化时，输出电流每变化0.1%(0.016mA),对应电位器值要变化: 4096/(0.128/0.016)=512 (电位器分成8档来旋)
      
      零点微调变化率(4096-2048)/16*2=00.256，即: 变化量为0.256mA，
      即: 输出电流每变化0.1%(0.016mA),对应电位器值要变化: 4096/(0.256/0.016)=256    (电位器分成16档来旋)
      */ 
      /**********************************************************************************/ 

      /*
      //不做电位器修正,直接上位机校对修正处理
      sam=(long)sam*kkk/16384+nnn; 
      */     

      
      /**********************************************************************************/       
      //输出电流 ZYF++.2011.4.13
      adsam[9]=sam;      
      if (num==0)
            TACCR2=adsam[9];
      else 
            TACCR1=adsam[9];
      /**********************************************************************************/             
      }
}
/******************************************************************************************************************************/ 


/********************************************************************************************************************/    
/******* 两路输出分别做温漂的简单线性补偿处理 ZYF++.2012.6.29 ********/ 
/*
      if (num==0)
            {
                  adsam[9] = sam;
                  K_add=(I_value_test1-I_value_ref1)/(T_test-T_ref);    
                  adsam[9]=(int)(adsam[9]-(K_add*(adsam[11]-T_ref)));
                  TACCR2=adsam[9];
            }
      else 
            {
            adsam[9] = sam; 
            K_add=(I_value_test2-I_value_ref2)/(T_test-T_ref);
            adsam[9]=(int)(adsam[9]-(K_add*(adsam[11]-T_ref)));
            TACCR1=adsam[9];
            }
*/
            
/*
      //三地址设置初始值
      T_value_ref,     2,          0,          0,          25,            //作温漂简单线性补偿用的温度变化前的基准值(-20~60)
      K_add1,          2,          0,          0,          0,            //第1路温漂线性补偿系数值(正系数(0~8)为: 0~32768,负系数(-8~0)为: -32768~0；则温漂补偿系数最大只能补偿正负0.05%F.S/℃即对应电流值-00008~00008)
      K_add2,          2,          0,          0,          0,            //第2路温漂线性补偿系数值
    

1)上位机手动预置下列地址的数值用于后续计算计算完后并通讯给430单片机: 
      T_value_ref
2)上位机手动读入下列数值: 
      I_value_test1
      I_value_ref1
      I_value_test2
      I_value_ref2
      T_test
3)上位机计算1:   
      （补偿范围温漂最大值到气温每变化1度输出电流变化正负5/万 即对应电流值-00008~00008）     
      K_add_P=(I_value_test1-I_value_ref1)/(T_test-(*(int *)(T_value_ref)); 
      K_add=K_add_P*(32768/8)       0(正系数(0~8)为: 0~32768,负系数(-8~0)为: -32768~0；则温漂补偿系数最大只能补偿正负0.05%F.S/℃即对应电流值-00008~00008)
  存入地址1待通讯给430单片机: (*(int *)(K_add1)
 上位机计算2:    
      K_add_P=(I_value_test2-I_value_ref2)/(T_test-(*(int *)(T_value_ref)); 
      K_add=K_add_P*(32768/8)       (正系数(0~8)为: 0~32768,负系数(-8~0)为: -32768~0；则温漂补偿系数最大只能补偿正负0.05%F.S/℃即对应电流值-00008~00008)
  存入地址1待通讯给430单片机: (*(int *)(K_add2)         
4)上位机把上述三个地址的值通讯给430CPU 
//从上位机读取相应地址存储的数值:     K_add=(*(int *)(地址名))
*/
/********************************************************************************************************************/ 
            
/*      
      if (num==0)
            {
            adsam[9] = sam;  
            adsam[9]=(int)(adsam[9]-(*(int *)(K_add1))*(adsam[11]-(*(int *)(T_value_ref)))/(32768/8));  
            TACCR2=adsam[9];
            }
      else
            {
            adsam[9] = sam;  
            adsam[9]=(int)(adsam[9]-(*(int *)(K_add2))*(adsam[11]-(*(int *)(T_value_ref)))/(32768/8));              
            TACCR1=adsam[9];            
            // test_TT1=(*(int *)(K_add2));
            }
*/
            
/********************************************************************************************************************/ 
/******* 两路输出分别做温漂的简单线性补偿处理 ZYF++.2012.6.29 ********/
/*      
            //作温漂分段线性补偿用地址分配 ZYF++.2012.7.3
            #define     K1_point1         0x106C
            #define     K1_point2         0x106E
            #define     K1_point3         0x1070
            #define     K1_point4         0x1072
            #define     K1_point5         0x1074

            #define     K2_point1         0x105C
            #define     K2_point2         0x105E
            #define     K2_point3         0x104C
            #define     K2_point4         0x104E
            #define     K2_point5         0x1042

            #define     T_value_ref       0x107A
            #define     section_flag      0x1040
            

      if (num==0)             //第1路线性补偿
            {
            adsam[9] = sam;               
            switch(*(U8 *)(section_flag))           //从上位机取分段补偿段数标志  
                  {
                        case 1: 				//单段线性补偿
                              KK_add1=(*(int *)(K1_point3));
                  		break;
            		case 2:                       //分2段线性补偿
                              {
                              K1_section1=((*(int *)(K1_point3))+(*(int *)(K1_point1)))/2;
                              K1_section2=((*(int *)(K1_point3))+(*(int *)(K1_point5)))/2;
                              if(adsam[12]<((slh+sll)/2))         KK_add1=K1_section1;
                              else        KK_add1=K1_section2; 
                              }
                              break;
            		case 4:                       //分4段线性补偿
                              {
                              K1_section1=((*(int *)(K1_point1))+(*(int *)(K1_point2)))/2;
                              K1_section2=((*(int *)(K1_point2))+(*(int *)(K1_point3)))/2;
                              K1_section3=((*(int *)(K1_point3))+(*(int *)(K1_point4)))/2;
                              K1_section4=((*(int *)(K1_point4))+(*(int *)(K1_point5)))/2;
                              if((adsam[12]-sll)/((slh-sll)/4)==0)     KK_add1=K1_section1;
                              else if((adsam[12]-sll)/((slh-sll)/4)==1)     KK_add1=K1_section2;
                              else if((adsam[12]-sll)/((slh-sll)/4)==2)     KK_add1=K1_section3;
                              else ((adsam[12]-sll)/((slh-sll)/4)==3)     KK_add1=K1_section4;
                              }
                  		break;
            		default :                     
            			KK_add1=0;
            			break;
                  }            
            adsam[9]=(int)(adsam[9]-KK_add1*(adsam[11]-(*(int *)(T_value_ref)))/(32768/8));
            TACCR2=adsam[9]; 
            }
      else              //第2路线性补偿
            {
            adsam[9] = sam;               
            switch(*(U8 *)(section_flag))           //从上位机取分段补偿段数标志  
                  {
                        case 1: 				//单段线性补偿
                              KK_add2=(*(int *)(K2_point3));
                  		break;
            		case 2:                       //2段分段线性补偿
                              {
                              K2_section1=((*(int *)(K2_point3))+(*(int *)(K2_point1)))/2;
                              K2_section2=((*(int *)(K2_point3))+(*(int *)(K2_point5)))/2;
                              if(adsam[12]<((slh+sll)/2))         KK_add2=K2_section1;
                              else        KK_add2=K2_section2; 
                              }
                              break;
            		case 4:                       //4段分段线性补偿
                              {
                              K2_section1=((*(int *)(K2_point1))+(*(int *)(K2_point2)))/2;
                              K2_section2=((*(int *)(K2_point2))+(*(int *)(K2_point3)))/2;
                              K2_section3=((*(int *)(K2_point3))+(*(int *)(K2_point4)))/2;
                              K2_section4=((*(int *)(K2_point4))+(*(int *)(K2_point5)))/2;
                              if((adsam[12]-sll)/((slh-sll)/4)==0)     KK_add2=K2_section1;
                              else if((adsam[12]-sll)/((slh-sll)/4)==1)     KK_add2=K2_section2;
                              else if((adsam[12]-sll)/((slh-sll)/4)==2)     KK_add2=K2_section3;
                              else ((adsam[12]-sll)/((slh-sll)/4)==3)     KK_add2=K2_section4;
                              }
                  		break;
            		default :                     
            			KK_add2=0;
            			break;
                  }            
            adsam[9]=(int)(adsam[9]-KK_add2*(adsam[11]-(*(int *)(T_value_ref)))/(32768/8));
            TACCR1=adsam[9]; 
            }
*/            
 
 /********************************************************************************************************************/ 


//线性化曲线
//sort=曲线编号，sam=被测物理量
int XIANXINHUA(U8 sort,int sam)
{
    int tong;
    
    if (sam<0) sam=0;
    else if (sam>18432) sam=18432;
    	
    //先查询被测AD脉冲位于哪一小段 zyf++.2011.7.13
    i=sam/512;
    /************************ zyf++.2011.7.13 ****************************
    对非线性曲线的等效计算思路_进行微分处理: 
    1. 把满量程脉冲18432,每512个脉冲分为一段，共细分为36小段(共有37个断点)
    2. AD采样脉冲 和 输入电信号 成线性关系, 可以上位机校对，AD线性计算出每个断点 输入电压或电阻信号 对应的 AD采样脉冲值
    3. 输入电信号 和 温度 成非线性关系，可以通过查<<常用热电偶、热电阻分度表>> 得每个断点电压或电阻信号 对应的 温度值,并填表
    4. (只要该小段细分的足够小)每个小段可以看成: AD采样脉冲 和 温度 成线性关系, 则可在该小段内线性计算出: 被测AD采样脉冲 对应的 温度值
    这样通过微分处理可近似计算出: 任意被测脉冲 对应的 温度值
    **********************************************************************/
    //再在该小段内线性计算出脉冲对应的近似温度值 zyf++.2011.7.13 
    sam=sam-512*(int)i;
    tong=(quxian[sort][i+1]-quxian[sort][i]);
    tong=(long)tong*((long)sam/512);
    tong=tong+quxian[sort][i];
    return tong;
}

//反线性化曲线
//sort=曲线编号，sam=被测物理量
int  AXIANXINHUA(U8 sort,int sam)
{
    int  n0,n1; 
     
    /********* 反线性化查表前对偶型不同小数点位数的特殊计算处理 zyf++.2011.7.13 *********/
    /*
      针对TC1047温度传感器采样得室温后等效的看成热电偶传感器采样的温度,进行反线性化查表做冷补叠加前: 不同小数点位数的不同计算处理
    */
    if((fdh<7)||(fdh==10))      //偶型
     {
       if(fdh==4)             //两位小数点处理: (T型)                             
        	sam=sam*100;
      else                    //一位小数点处理
        	sam=sam*10;
     }  
    /**********************************************************************************/ 
       
    for (i=0;i<36;i++)  if ((quxian[sort][i]<=0)&&(quxian[sort][i+1]>=0))   break;    //先查询温度0度 位于哪一小段 zyf++.2011.7.13
    n0=512*i+(long)512*(long)(0-quxian[sort][i])/(quxian[sort][i+1]-quxian[sort][i]);   //再在该小段内逆向线性计算出温度0度对应的近似脉冲 zyf++.2011.7.13
    for (i=0;i<36;i++)  if ((quxian[sort][i]<=sam)&&(quxian[sort][i+1]>=sam)) break;      //先查询被查温度位于哪一小段 zyf++.2011.7.13
    n1=512*i+(long)512*(long)(sam-quxian[sort][i])/(quxian[sort][i+1]-quxian[sort][i]);   //再在该小段内逆向线性计算出温度对应的近似脉冲 zyf++.2011.7.13         
    return (n1-n0);
}



void Init(void)
{
    const U8 btca[8]=
    {
        0x1b,0x03,  	//32768/(27+(2/8))= 1202
        0x0d,0x6b,  	//32768/(13+(5/8))= 2405
        0x06,0x6f,  	//32768/( 6+(6/8))= 4854
        0x03,0x4a   	//32768/( 3+(3/8))= 9709
    };  			//波特率    
    U8 bt;

    //系统时钟-MCLK=5000000,SMCLK=5000000/8=600000
    //DCOCTL =DCO2+DCO1+DCO0+MOD4+MOD3+MOD2+MOD1+MOD0;
    DCOCTL = DCO2+DCO1+DCO0;            //最高频率
    BCSCTL1=XT2OFF+RSEL2+RSEL1+RSEL0 ;  //选用最高标称频率的上拉电阻
    BCSCTL2=0;					//MCLK时钟源为DCO,分频因子为1,SMCLK时钟源为1,SMCLK分频因子为1,选择内部电阻
  //  delay(6000);


    //WDT看门狗为：定时器+2MS
    WDTCTL=WDTPW+WDTTMSEL+WDTCNTCL+WDTIS0;            //2ms
    IE1   =IE1|WDTIE;

    //定时器A(PWM输出)
    TACTL  =TASSEL1+MC0;//+ID1+ID0;
    //TACTL=0x0216;
    TACCTL0=0;
    TACCTL1=OUTMOD_3;//OUTMOD_7;
    TACCTL2=OUTMOD_3;//OUTMOD_7;
    TAR    =0;
    TACCR0 =20000;
    TACCR1 =14000;
    TACCR2 =14000;

    //AD模数转换器
    P6DIR = 0;
    ADC12CTL0&=(~ENC);
    ADC12MCTL0=SREF_1+INCH_0;
    ADC12MCTL1=SREF_1+INCH_1;
    ADC12MCTL2=SREF_1+INCH_2;
    ADC12MCTL3=SREF_1+INCH_5;
    ADC12MCTL4=SREF_1+INCH_6;
    ADC12MCTL5=EOS+SREF_1+INCH_7;
    ADC12IE=0;
    ADC12CTL0 =0;
    ADC12CTL0 =MSC+REF2_5V+REFON+ADC12ON;
    ADC12CTL0|=SHT0_6;
    ADC12CTL0|=SHT1_6;
    ADC12CTL1 =SHP;
    ADC12CTL1|=ADC12SSEL_0;
    ADC12CTL1|=CONSEQ_1;
    ADC12CTL1|=ADC12DIV_0;
    ADC12CTL1|=CSTARTADD_0;
    ADC12CTL0|=ENC;

    ADC12MEM0=0;
    ADC12MEM1=0;
    ADC12MEM2=0;
    ADC12MEM3=0;
    ADC12MEM4=0;
    ADC12MEM5=0;
    ADC12MEM6=0;
    ADC12MEM7=0;
    ADC12MEM8=0;
    ADC12MEM9=0;
    ADC12MEM10=0;
    ADC12MEM11=0;
    ADC12MEM12=0;
    ADC12MEM13=0;
    ADC12MEM14=0;
    ADC12MEM15=0;


    //UARTO通讯模块
    bt=(*(U8 *)ADR_BT);
    if (bt>3) bt=2;
    
    UCTL0 =CHAR+SPB;                //-----在此测试，发现无论停止位设为1位还是2位，通讯均能正常工作。
    UTCTL0=SSEL0;           //选用ACLK作为波特率时钟
    
    URCTL0=0;
    UBR00 =btca[2*bt];      //UBR00 与 UBR10 合成,波特率=UBR10*256+UBR00
    UBR10 =0;
    UMCTL0=btca[2*bt+1];    //波特率调整
    ME1   =URXE0+UTXE0;     //使能USART0 TXD/RXD
    IE1   =IE1|URXIE0;      //使能USART0 RX中断
                            //
    get_ads_adr();
}

//初始化FLASH
void FLASH_CHU(void)
{
    if (*(U8 *)ADR_FDH==0xff)
    {
        for (zj1=0;zj1<CD_LEN;zj1++)
            FLASH_WW(caidan[zj1].address,caidan[zj1].set,caidan[zj1].leng);

    }

}


/****************************************************************************
                         FLASH 参数处理程序 
***************************************************************************/
//读段内数据（字,字节）
//ADDR=段内的任何地址
//SORT=数据类型（字,字节）
int FLASH_RW(unsigned int addr,U8 sort)
{
    int data;
    if (sort==2)
        data=*(int *)addr;
    else
        data=*(U8 *)addr;
    return data;
}

//写段内数据（字,字节）
void FLASH_WW(unsigned int addr,int word,U8 sort)
{
    FCTL1 = 0x0A540;
    FCTL2 = 0x0A542;
    FCTL3 = 0x0A500;
    _DINT();
    if (sort==2) (*(int *)addr)=word;
    else (*(U8 *)addr)=word;
    _EINT();
    FCTL3 = 0x0A510;
}

//擦除被信息段
//ADDR=段内的任何地址
void FLASH_MCLR(unsigned int addr)
{
    int *Data_ptr;
    Data_ptr=(int *)addr;
    FCTL1 = 0x0A504;
    FCTL2 = 0x0A542;
    FCTL3 = 0x0A500;
    _DINT();
    P4OUT=0;
    *Data_ptr=0;
    _EINT();
    FCTL3 = 0x0A510;
}

//擦除被选择段
//ADDR=段内的任何地址
void FLASH_CLR(unsigned int addr)
{
    int *Data_ptr;
    Data_ptr=(int *)addr;
    FCTL1 = 0x0A502;
    FCTL2 = 0x0A542;
    FCTL3 = 0x0A500;
    _DINT();
    P4OUT=0;
    *Data_ptr=0;
    _EINT();
    FCTL3 = 0x0A510;
}

//拷贝段数据
void FLASH_COPY(void)
{
    	for (zj1=0;zj1<CD_LEN;zj1++)
    	{
        	zj2=FLASH_RW(caidan[zj1].address+FSEG,caidan[zj1].leng);
        	if (((caidan[zj1].leng==2)&&(zj2==-1)) || ((caidan[zj1].leng==1)&&(zj2==255)))
        	{
            	zj3=FLASH_RW(caidan[zj1].address,caidan[zj1].leng);
            	if (zj2!=zj3) 
            	{
            		FLASH_WW(caidan[zj1].address+FSEG,zj3,caidan[zj1].leng);
            	}
        	}
    	}
    	FLASH_CLR(FSEGB);

    	for (zj1=0;zj1<CD_LEN;zj1++)
    	{
        	zj2=FLASH_RW(caidan[zj1].address+FSEG,caidan[zj1].leng);
 /*       	if (zj2<-2000)
        	{
            	zj2=zj2+2000;
            } */
            
        	zj3=FLASH_RW(caidan[zj1].address,caidan[zj1].leng);
        	if (zj2!=zj3)
        	{
            	FLASH_WW(caidan[zj1].address,zj2,caidan[zj1].leng);
            }
    	}
    	FLASH_CLR(FSEGA);
}

/****************************************************************************
                         通讯处理程序 
***************************************************************************/
//UART0通讯接收程序
//interrupt [UART0RX_VECTOR]     void UART0RX(void)
#pragma vector=UART0RX_VECTOR
__interrupt void UART0RX(void)
{
    static U8 rxd[10],rleng;
    //static           int i;
    //unsigned x;
    _BIS_SR(GIE);
    uch=U0RXBUF;
    if (uch==251)
    {
        IE1=IE1&0XBF;
        if (uch!=251)
        {
            IE1=IE1|0x40;    													//调试通讯
            return;
        }
        uch=RRXDB();
        if (uch!=252)
        {
            IE1=IE1|0x40;
            return;
        }
        uch=RRXDB();
        if (uch!=253)
        {
            IE1=IE1|0x40;
            return;
        }
        WTXDB(252);
        WTXDB(253);
        WTXDB(254);
        for (;;)
        {
            uch=RRXDB();
            switch (uch)
            {
            case 0:                             //退出通讯
                break;                                                         	
            case 1:                             //字节写
                uchh=RRXDB();
                if (rov==1)
                {
                    uch=1;    
                    break;
                }
                uchl=RRXDB();
                if (rov==1)
                {
                    uch=1;
                    break;
                }
                uch =RRXDB();
                if (rov==1)
                {
                    uch=1;
                    break;
                }
                if (uchh==0x18)             //处理变送校对
                {
                    leng=uch;
                }
                else
                {
                    if ((uchh==0x10)&&(uchl <0x80))
                    {
                        eeprom=1;
                        FLASH_WW((uchh<<8)+uchl+0x80,uch,1);
                    }
                }
                uch=1;
                break;
            case 2:                             //字节读
                uchh=RRXDB();
                if (rov==1)     //等待超时
                {
                    uch=2;    
                    break;
                }
                uchl=RRXDB();   //等待超时
                if (rov==1)
                {
                    uch=2;
                    break;
                }
                uch=*(U8 *)((uchh<<8)+uchl);
                WTXDB(uch);
                uch=2;
                break;
            case 3:                             //块写
                eeprom=0x80;                                                  	
                FLASH_CLR(0x1000);
                for (uadr=0x1000;uadr<0x1080;uadr++)
                {
                    uch=RRXDB();
                    if (rov==1)break;
                    FLASH_WW(uadr,uch,1);
                }
         /*      FLASH_CLR(0xF800);
                for (uadr=0xF800;uadr<0xF900;uadr++)
                {
                    uch=RRXDB();
                    if (rov==1)break;
                    FLASH_WW(uadr,uch,1);
                }
          */      
                uch=3;
                break;
            case 4:                             //块读
                for (uadr=0x1000;uadr<0x1080;uadr++)
                {
                    uch=*(U8 *)uadr;    								
                    WTXDB(uch);
                }
         /*      for (uadr=0xF800;uadr<0xF900;uadr++)
                {
                    uch=*(U8 *)uadr;
                    WTXDB(uch);
                }
          */   
                break;
            case 5:                             //3通道类型
                uch=0;
                WTXDB(uch);
                WTXDB(fdh);
                WTXDB(0x00);
                WTXDB(0x00);                                         			
                for (i=0;i<15;i++)
                {
                    inch.sint=adsam[i];
                    WTXDB(inch.ch[0]);
                    WTXDB(inch.ch[1]);
                }
                uch=5;
                break;
            case 6:                             //块写	
                eeprom=0x80;                                                    
                FLASH_CLR(0x1000);		//注意，擦除FLASH需要一定时间，发完6后需延迟100ms左右再发下面的数据。
                for (uadr=0x1000;uadr<0x1080;uadr++)
                {
                    uch=RRXDB();
                    if (rov==1)break;
                    FLASH_WW(uadr,uch,1);
                }
                uch=3;
                break;
            case 7:                             //块读
                for (uadr=0x1000;uadr<0x1080;uadr++)
                {
                    uch=*(U8 *)uadr;    								
                    WTXDB(uch);
                }
                break;
            default:
                break;
            }
            if ((uch==1)||(uch==2)) continue;
            else
            {
                IE1=IE1|0x40;
                return;
            }
        }
    }
    else
    {
        rxd[rleng]=U0RXBUF;
        if (rxd[rleng]!=0x0d)
        {
            if (rxd[0]==0x40) rleng++;
            else rleng=0;
            if (rleng>9) rleng=9;
            return;
        }
        rleng=0;
        for (;;)																//@01RD17\0D
        {
            if (rxd[0]!='@')              	break;
            if (rxd[1]!=BINTOASC(de/16))   	break;
            if (rxd[2]!=BINTOASC(de%16))   	break;
            crc=rxd[1]^rxd[2]^rxd[3]^rxd[4];
            if (rxd[3]!='R')
            {
                ERROR();
                break;
            }
            if (rxd[4]!='D')
            {
                ERROR();
                break;
            }
            if (rxd[5]!=BINTOASC(crc/16))
            {
                ERROR();
                break;
            }
            if (rxd[6]!=BINTOASC(crc%16))
            {
                ERROR();
                break;
            }
            if (rxd[7]!=0x0d)
            {
                ERROR();
                break;
            }

            WTXDB('@');
            crc=0;
            DWTXDB(de);
            WTXDB('R');
            WTXDB('D');
            
            
//-------------------------------------------------------------------------->> 2012.7.4 把相应数组值通讯给上位机以显示           
            inch.sint=adsam[12];                //叠加冷补后的采样结果温度值
            DWTXDB(inch.ch[0]);
            DWTXDB(inch.ch[1]);
            uch=*(U8 *)ADR_DOT;      //小数点
            DWTXDB(uch);
            WTXDB(BINTOASC(crc/10));
            WTXDB(BINTOASC(crc%10));
            WTXDB(0x0d);
//-------------------------------------------------------------------------
            #if 0
            WTXDB(0x0A);  

            inch.sint=adsam[4];                 //AD1110的采样脉冲数
            DWTXDB(inch.ch[0]);
            DWTXDB(inch.ch[1]);

            inch.sint=adsam[11];                //TC1047转换室温
            DWTXDB(inch.ch[0]);
            DWTXDB(inch.ch[1]);

            inch.sint=adsam[0];                 //ds18b20温度(外冷补)
            DWTXDB(inch.ch[0]);
            DWTXDB(inch.ch[1]);

            inch.sint=adsam[1];                 //温度经TC1047转换电压后经430内置AD转换为脉冲数
            DWTXDB(inch.ch[0]);
            DWTXDB(inch.ch[1]);

            inch.sint=adsam[13];                      //零点脉冲
            DWTXDB(inch.ch[0]);
            DWTXDB(inch.ch[1]);  

            inch.sint=adsam[14];                      //终点脉冲
            DWTXDB(inch.ch[0]);
            DWTXDB(inch.ch[1]);  
            #endif
//--------------------------------------------------------------------------<<------------------------------------
            
            
            return;
        }
    }
}

//单字节读送rs485=0
U8 RRXDB(void)
{
    P3OUT=P3OUT&(~RS485);
    for (rovti=0;;)
    {
        if ((IFG1&URXIFG0)!=0)
        {
            rov=0;
            return U0RXBUF;
        }
        else
        {
            if (rovti>230)
            {
                rov=1;
                return 0;
            }
        }
    }
}
//单字节发送rs485=1;
void WTXDB(U8 ch)
{
    static int i;
    P3OUT=P3OUT|RS485;
    U0TXBUF=ch;
    crc=crc^ch;
    while ((UTCTL0&0X01)==0){};
    for (i=0;i<1250;i++);
}

//单字节转为ASC码双字节发送
void DWTXDB(U8 ch)
{
    WTXDB(BINTOASC(ch/16));
    WTXDB(BINTOASC(ch%16));
}
//ASC码转二进制
U8 ASCTOBIN(U8 ch)
{
    const U8 BIND[24]={0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,10,11,12,13,14,15,16};
    return BIND[ch-48];
}
//二进制转ASC码
U8 BINTOASC(U8 ch)
{
    const U8 ASCD[16]={0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x41,0x42,0x43,0x44,0x45,0x46};
    return ASCD[ch&0x0f];
}
//出错应答
void ERROR(void)
{
    WTXDB(0x40);
    crc=0;
    DWTXDB(de);
    WTXDB('*');
    WTXDB('*');
    DWTXDB(crc);
    WTXDB(0x0d);
}
//正确应答
void RIGHT(void)
{
    WTXDB(0x40);
    crc=0;
    DWTXDB(de);
    WTXDB('#');
    WTXDB('#');
    DWTXDB(crc);
    WTXDB(0x0d);
}


/****************************************************************************
                         ADS1110 读写程序 
***************************************************************************/
//取得ADS1110的地址
void get_ads_adr(void)
{
    const U8 adsedx[8]={ED0,ED1,ED2,ED3,ED4,ED5,ED6,ED7};
    U8 x;
    for(x=0;x<8;x++)
    {       
            ADS_ADDR = adsedx[x];
            adsiicstart();
            if(adswbyte(ADS_ADDR)==1)
            {
                adsiicstop();
                return;
            }
            adsiicstop();
    }
}
//16位模数转换器-----ADS1100(ED4)
//i2c操作总线
//按地址读一字节
void adsread(void)
{
    adsiicstart();
    adswbyte(ADS_ADDR|1);
    adsdata[0]=adsrbyte();
    adsdata[1]=adsrbyte();
    adsdata[2]=adsrbyte();        // ? zsm
    adsiicstop();
}

void adswrite(U8 data)
{
    adsiicstart();
    adswbyte(ADS_ADDR);
    adswbyte(data);
    adsiicstop();
}

void adsiicstart(void)
{
    P6DIR|=ADSSDA;
    P6DIR|=ADSSCL;
    P6OUT|=ADSSDA;
    _NOP();
    _NOP();
    _NOP();
    P6OUT|=ADSSCL;
    _NOP();
    _NOP();
    _NOP();
    P6OUT&=~ADSSDA;
    _NOP();
    _NOP();
    _NOP();
}

void adsiicstop(void)
{
    P6DIR|=ADSSDA;
    P6OUT&=~ADSSDA;
    _NOP();
    _NOP();
    _NOP();
    P6OUT|=ADSSCL;
    _NOP();
    _NOP();
    _NOP();
    P6OUT|=ADSSDA;
    _NOP();
    _NOP();
    _NOP();
}

U8 adswbyte(U8 adbyte)
{
    static U8 wbi;
    U8         wbj=0;
    P6DIR|=ADSSDA;
    P6OUT&=~ADSSCL;
    for (wbi=0;wbi<8;wbi++)
    {
        if ((adbyte&0x80)==0)
            P6OUT&=~ADSSDA;
        else
            P6OUT|=ADSSDA;
        adbyte=(adbyte&0x7f)*2;
        _NOP();_NOP();_NOP();
        P6OUT|=ADSSCL;
        _NOP();_NOP();_NOP();
        P6OUT&=~ADSSCL;
        _NOP();_NOP();_NOP();
    }
    //P6OUT|=ADSSDA;
    P6DIR&=~ADSSDA;
    P6OUT|=ADSSCL;
    _NOP();_NOP();_NOP();
    
    do
    {
        wbi=(P6IN&ADSSDA);
        if(wbj++>200)return 0;
    }
    while (wbi==ADSSDA);
    
/*
    for(wbi=200;wbi>0;wbi--)                  //停在高电平上,等待下降沿
    {
       if( P6IN&ADSSDA)
       {
           if(i<=2)
           {
               P6OUT&=~ADSSCL;
               _NOP();_NOP();_NOP();    
               return 0;     
           }
       }
       else
           break;
    }
*/
    P6OUT&=~ADSSCL;
    _NOP();_NOP();_NOP();
    return 1;
}

//读一字节
U8 adsrbyte(void)
{
    static U8 wbi,byte;
    byte=0;
    P6DIR&=~ADSSDA;
    for (wbi=0;wbi<8;wbi++)
    {
        P6OUT&=~ADSSCL;
        _NOP();
        _NOP();
        _NOP();
        P6OUT|=ADSSCL;
        _NOP();
        _NOP();
        _NOP();
        if ((P6IN&ADSSDA)==ADSSDA) byte=byte*2+1;
        else byte=byte*2;
    }
    P6OUT&=~ADSSCL;
    P6DIR|=ADSSDA;
    P6OUT&=~ADSSDA;
    _NOP();
    _NOP();
    _NOP();
    P6OUT|=ADSSCL;
    _NOP();
    _NOP();
    _NOP();
    P6OUT&=~ADSSCL;
    P6DIR&=~ADSSDA;
    return byte;
}
/****************************************************************************/



/****************************************************************************
                         18B20读写程序
 
时序: 
第一周期: 复位,跳过ROM指令,温度转换,等待500us 
第二周期: 复位,跳过ROM指令,读RAM指令,读数据 
***************************************************************************/
int read_temp(void)
{
    int Temperature=0;
    //U8 i;
/****************************************************************************** 
    //注意:如时钟符合要求则不需更改,否则需重新设定时钟
    DCOCTL=0XFF;				//直接选用最高频率
    BCSCTL1&=0XF8;				//清最后3位
    BCSCTL1|=0X07;   //5M		//选用最高标称频率的上拉电阻
    BCSCTL2=0;					//MCLK时钟源为DCO,分频因子为1,SMCLK时钟源为1,SMCLK分频因子为1,选择内部电阻
    delay(6000);
*/
    //BCSCTL2=0;
    if(Reset_ds()<=0)           //复位,同时判断18B20是否存在.
    {
        return -16384;
    }
    //Reset_ds();				
                            //
    Write_ds(0xcc);			//跳过ROM指令
    Write_ds(0x44);			//温度转换
    
    //for (i=0;i<5;i++)		//等待>500us
    //{
        delay(21000);
    //}

    Reset_ds();             //复位
    Write_ds(0xcc);         //跳过ROM指令
    Write_ds(0xbe);         //读RAM指令
    Temperature=Read_ds();  //读温度值
    Reset_ds();
    delay(4200);
    delay(6000);

    return Temperature;
}

char Reset_ds(void)
{
    U8 i;
    PDIR_DS|= ADDR_DS;
    POUT_DS&=~ADDR_DS;          //输出0
    delay(480);
    //POUT_DS|= ADDR_DS;          //上拉,等待高电平
    PDIR_DS&=~ADDR_DS;          //输入
    delay(30);   
    for(i=100;i>0;i--)                  //停在高电平上,等待下降沿
    {
       if( PIN_DS&ADDR_DS)
       {
           if(i<=2)
               return 0;     
       }
       else
           break;
    }

    for(i=100;i>0;i--)                  //停在低电平上,等待上升沿
    {
       if(~PIN_DS&ADDR_DS)
       {
           if(i<=2)
               return 0;     
       }
       else
           break;
    }
    //while(~PIN_DS&ADDR_DS);   	
    return 1;
}

void Write_ds(U8 data)
{
    U8 i;
    PDIR_DS|= ADDR_DS;                                              //输出
    for (i=0;i<8;i++)
    {
        POUT_DS|= ADDR_DS;
        delay(10);   //输出1
        POUT_DS&=~ADDR_DS;
        delay(10);   //输出0
        if ((data&1)==1)
        {
            POUT_DS|= ADDR_DS;
        }
        else
        {
            POUT_DS&=~ADDR_DS;
        }
        data=data/2;
        delay(40);
    }
    PDIR_DS|=ADDR_DS;
    POUT_DS|=ADDR_DS;
    delay(400);
}

int Read_ds(void)
{
    U8 i;
    unsigned int  temp=0;
    for (i=1;i<17;i++)
    {
        PDIR_DS|= ADDR_DS;
        POUT_DS|= ADDR_DS;
        delay(2);       //输出1
        POUT_DS&=~ADDR_DS;
        delay(0);       //输出0
        PDIR_DS&=~ADDR_DS;
        delay(9);                       //输入
        temp=(temp>>1);
        if ((PIN_DS&ADDR_DS)==ADDR_DS)
        {
            temp|=0x8000;
        }
        delay(40);
    }
    PDIR_DS|=ADDR_DS;
    POUT_DS|=ADDR_DS;
    return((long)temp*100/16);        //2个小数点精度
}
/*******************************************************************************/